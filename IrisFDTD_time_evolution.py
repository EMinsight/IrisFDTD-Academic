"""
Copyright (C) 2019-2020 Sergio G Rodrigo <sergut@unizar.es>

**Important:** 
*IrisFDTD* is licensed under the AGPL and it is free to use. 
if you are using, or plan to use this example, specially if it is 
for research or academic purposes, please send an email with your name, 
institution and a brief description of your interest for this program. 
"""

class fdtdEMt:

 def __init__(self,initime,endtime,nx,ny,path,filename,ext):
    self.nx=nx
    self.ny=ny   
    self.initime=initime
    self.endtime=endtime    
    self.path=path      
    self.filename=filename    
    self.ext = ext #Extension and filenamee of SDL files determine the actual field, component and value 
    pass
  
 #Converts fdtd.em to a redable format for matplotlib.pyplot to generate contour color maps
 def setpyplotformat(self):
    # A function to postprocessing files generated by unload_near_field() in IrisFDTD             
    import numpy as np 
    import struct
    import os 
    import sys
    
    nx=self.nx
    ny=self.ny        
    init=self.initime
    endt=self.endtime
    path=self.path
    filename=self.filename        
    ext=self.ext
    t = []
    
    chunksize=4 #Reading chuncks of 4 bytes   
    
    # 3D matrix is build. nx*ny matrices from initime to endtime
    Z = [] 
    Z.append(np.zeros((ny,nx)))    
    
    print("Building SDL matrices")    
    for l in range(init,endt): 
      fname=filename+str(l)+ext      
      fileSDL=os.path.exists(path+fname)
      if (fileSDL):           
        #First 4 bytes are intruduced by Fortran and just garbage. The same for the last 4 bytes        
        i=1; j=1; t=[];
        with open(path+fname, "rb") as f:       
              chunk = f.read(chunksize) #First chunk is removed      
              while (j <= nx*ny):
                chunk = f.read(chunksize)            
                t.append(struct.unpack("f", chunk))           
                j=j+1                        
        i=0;j=0;s=0
        while (s < nx*ny ):            
            b, = t[s]
            Z[l-init][j,i]= b
            i=i+1    
            s=s+1
            if (i%(nx) == 0.0):
                j=j+1 
                if(j==ny): break    
                i=0              
        Z.append(np.zeros((ny,nx)))     
        print(filename+str(l)+self.ext)
      else:  
        print(path+fname+" doesn't exist! The program will stop")        
        sys.exit()
        
    print("Building SDL matrices done")     
    
    Z=np.array(Z,dtype='float')  
    return Z
    
    if(False):
        W = []      
        for r in Z: 
            W.append(self.dowithdata(r))        
        W=np.array(W)    
        return W # Here a list
    else:
        return Z
    
 pass


# Creates a film of the plane chosen
 def dowithdata(self,Z,**kwargs):
    # A function to postprocessing files generated by unload_near_field() in IrisFDTD         
    import numpy as np      
    S,W = [],[]
    W=np.rot90(Z)
    S=np.add(W,Z)
    S=S/2.0
    if(True):
        S=np.log10(S) # It generates some infinity values so it fails when tryring to calculaate the sum   
        print("WARNING: LOG ON")
    S=np.ones(S.shape)
    S= -1.86936*S
    return S
 pass

# Creates a film of the plane chosen
 def createmovie(self,Z,plane,videoname,title,**kwargs):
    # A function to postprocessing files generated by unload_near_field() in IrisFDTD         
    
    import matplotlib.pyplot as plt   
    import numpy as np      
    import os    
    
    nx=self.nx
    ny=self.ny    
    path=self.path
    filename=self.filename
    iplane=self.initime
    fplane=self.endtime
    endt=self.endtime
    
    # kwargs
    ititle=kwargs.get('ini',1.0) # Title can include the value of a magnitude such: "Title name (in units) = ini+delta*(i-1)"
    dtitle=kwargs.get('delta',1.0)
    labelcmap=kwargs.get('labelcmap',None)
    vmn=kwargs.get('vmin', None)
    vmx=kwargs.get('vmax', None)          
    numUC=kwargs.get('unit_cells',1)
    msize=kwargs.get('mesh_size',1.0) # in microns
            
    videoname=videoname+plane
    if(plane=="YZ"):           
        if(msize==1): xdir="y (mesh units)"
        else:         xdir="y ($\mu m$)"
        if(msize==1): ydir="z (mesh units)"
        else:         ydir="z ($\mu m$)"        
        numUCxdir=numUC; numUCydir=1
    if(plane=="XY"):       
        if(msize==1): xdir="x (mesh units)"
        else:         xdir="x ($\mu m$)"
        if(msize==1): ydir="y (mesh units)"
        else:         ydir="y ($\mu m$)"
        numUCxdir=numUC; numUCydir=numUC
    if(plane=="XZ"):           
        if(msize==1): xdir="x (mesh units)"
        else:         xdir="x ($\mu m$)"
        if(msize==1): ydir="z (mesh units)"
        else:         ydir="z ($\mu m$)"          
        numUCxdir=numUC; numUCydir=1
    
    prinfo=False
    
    # Sets the extent of the axes/plot
    dims=Z.shape    
    dims=np.array(dims,dtype='float')    
    print(dims[0],dims[1],dims[2]) #nx,nz,ny 
    
    dims[2]=numUCxdir*msize*dims[2]
    dims[1]=numUCydir*msize*dims[1]    
    # Either Field magnitude (Z), and vector field for several unit cells
    Z=np.tile(Z,(numUCydir,numUCxdir))      
    
    # Set the dimensions of meshgrid (X,Y) position for vector field
    dims2=Z.shape # Tuple with shape
    dims2=np.array(dims2) # Shape to array     
    
    # dpi, figx, figy have been chosen by hand --> no rule used
    dpi=200
    figx= 10 ; figy=figx*dims[1]/dims[2]
    fig=plt.figure(num=None, dpi=dpi,   figsize=(figx,figy), facecolor='b', edgecolor='k')
    # Creates .png files from Z-matrix
    # initiate an empty  list of "plotted" images 
    #myimages = []
    
    print("Creating .png files")   
    # https://matplotlib.org/3.1.1/gallery/images_contours_and_fields/interpolation_methods.html   
    # interpolation = [None, 'none', 'nearest', 'bilinear', 'bicubic', 'spline16',
    #   'spline36', 'hanning', 'hamming', 'hermite', 'kaiser', 'quadric',
    #   'catrom', 'gaussian', 'bessel', 'mitchell', 'sinc', 'lanczos']
    for l in range(iplane,fplane+1):
        if(prinfo): print("Figure loaded",l)    # cmap options = https://matplotlib.org/3.1.0/tutorials/colors/colormaps.html      
        imgplot=plt.imshow(Z[l-iplane], extent=[0.0, dims[2], 0.0,dims[1]], origin='lower',
                              cmap='hot',interpolation='gaussian',vmin=vmn, vmax=vmx)   #Z index stars at 0                
        #plt.axis(aspect='image')          
        plt.xlabel(xdir,fontsize=15)
        plt.ylabel(ydir,fontsize=15)
        #plt.title(title+str(ititle+(l-1)*dtitle),fontsize=20)               
        plt.title(title %(ititle+(l-1)*dtitle),fontsize=20)               
        clb = plt.colorbar()
        clb.ax.set_title(labelcmap,fontsize=15)        
        plt.savefig(path+"output"+str(l)+".png")                          
        #myimages.append([imgplot]) 
        plt.show() 
        plt.clf()  
        '''
        # Things for SERS pyramids
        A=np.array(Z[l-initime],dtype='float')
        b=A.sum()
        c=92976.0 #A.size Note that A.size=nx*ny but the actual number must be the name of points on the pyramid no the ones
                  #proyected. The FDTD code modified so por a (x,y) proyection is included the contribution for several z's in
                  # fort.88
        print(b/c)
        del A       
        '''
    print("Creating .png files done")    
    print("Creating animation")
    command="ffmpeg -framerate 1 -start_number "+str(iplane)+" -i "+path+"output%d.png "+path+videoname+".avi"
    print(command)
    videoexist=os.path.exists(path+videoname+".avi")
    print("The avi file already exist =",videoexist)
    if(videoexist): 
        os.remove(path+videoname+".avi")
        print("The previous avi file removed")
    ok=os.system(command)    
    if(ok==1):
        ok=False
    else:
        ok=True
    print("A new avi file has been created =",ok)
    if(ok==False):
        print("Check ffmpeg path and dimensions for MPEG-4 (dpi,figx and figy)")
    print("Creating animation done")       
     
    for l in range(iplane,fplane+1):         
        fname = path+"output"+str(l)+".png"
        if(True):os.remove(fname)
    print("Files output*.png removed")                
    
    pass